    env:
      - name: HOLY
        valueFrom:
          secretKeyRef:
            name: holy
            key: creditcard


kubectl -n one get secret s1 -ojsonpath="{.data.data}" | base64 -d

kubectl -n one get secret s2 -ojsonpath="{.data.data}" | base64 -d

apiVersion: apiserver.config.k8s.io/v1
kind: EncryptionConfiguration
resources:
  - resources:
      - secrets
    providers:
      - aescbc:
          keys:
            - name: key1
              secret: this-is-very-sec
      - identity: {}

================================

Create Namespace, ServiceAccount and Secrets
Create new Namespace ns-secure and perform everything following in there
Create ServiceAccount secret-manager
Create Secret sec-a1 with any literal content of your choice
Create Secret sec-a2 with any file content of your choice (like /etc/hosts )

Tips

k -n ns-secure create secret generic -h


Solution

k create ns ns-secure

k -n ns-secure create sa secret-manager

k -n ns-secure create secret generic sec-a1 --from-literal user=admin

k -n ns-secure create secret generic sec-a2 --from-file index=/etc/hosts

===

Create Pod that uses ServiceAccount and Secrets
Create Pod secret-manager image httpd:alpine which uses the new ServiceAccount
Make Secret sec-a1 available as environment variable SEC_A1
Mount Secret sec-a2 into the Pod read-only under /etc/sec-a2
Verify your solution worked

Solution

k -n ns-secure run secret-manager --image=httpd:alpine -oyaml --dry-run=client > pod.yaml

vim pod.yaml

Edit to:

apiVersion: v1
kind: Pod
metadata:
  labels:
    run: secret-manager
  name: secret-manager
  namespace: ns-secure
spec:
  volumes:
    - name: sec-a2
      secret:
        secretName: sec-a2
  serviceAccountName: secret-manager
  containers:
    - image: httpd:alpine
      name: secret-manager
      volumeMounts:
        - name: sec-a2
          mountPath: /etc/sec-a2
          readOnly: true
      env:
        - name: SEC_A1
          valueFrom:
            secretKeyRef:
              name: sec-a1
              key: user
  dnsPolicy: ClusterFirst
  restartPolicy: Always

  ===