

echo -n "this-is-very-sec" | base64
dGhpcy1pcy12ZXJ5LXNlYw==

mkdir /etc/kubernetes/etcd

vim /etc/kubernetes/etcd/ec.yaml
---
apiVersion: apiserver.config.k8s.io/v1
kind: EncryptionConfiguration
resources:
  - resources:
      - secrets
    providers:
      - aesgcm:
          keys:
            - name: key1
              secret: dGhpcy1pcy12ZXJ5LXNlYw==
      - identity: {}

==
## in kube-apiserver.yaml::

- --encryption-provider-config=/etc/etcd/ec.yaml
...
    - mountPath: /etc/etcd
      name: etc-etcd
      readOnly: true
...
  - hostPath:
      path: /etc/kubernetes/etcd
      type: DirectoryOrCreate
    name: etc-etcd

====
## reload secrets:
kubectl -n one get secrets -o json | kubectl -n one replace -f -
## all in all namespaces::
kubectl get secrets --all-namespaces -o json | kubectl replace -f -

===============================

Encrypt existing Secrets
Encrypt all existing Secrets in Namespace one using the new provider
Encrypt all existing Secrets in Namespace two using the new provider
Encrypt all existing Secrets in Namespace three using the new provider

Tip

Recreate Secrets so they are encrypted through the new encryption settings.


Solution

kubectl -n one get secrets -o json | kubectl replace -f -
kubectl -n two get secrets -o json | kubectl replace -f -
kubectl -n three get secrets -o json | kubectl replace -f -

To check you can do for example:

ETCDCTL_API=3 etcdctl --cert /etc/kubernetes/pki/apiserver-etcd-client.crt --key /etc/kubernetes/pki/apiserver-etcd-client.key --cacert /etc/kubernetes/pki/etcd/ca.crt get /registry/secrets/one/s1

The output should be encrypted and prefixed with k8s:enc:aesgcm:v1:key1.

===